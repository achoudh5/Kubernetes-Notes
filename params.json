{"name":"Kubernetes-notes","tagline":"","body":"## Definition \r\n\r\n* **Container Orchestration**- is the automatic process of managing or scheduling the work of individual containers for applications based on microservices within multiple clusters.\r\n\r\n* **Container orchestration**- automates the deployment, management, scaling, and networking of containers. Enterprises that need to deploy and manage hundreds or thousands of LinuxÂ® containers and hosts can benefit from container orchestration. Container orchestration can be used in any environment where you use containers\r\n\r\n* **Nodes**- Machine either physical or virtual; Containers are launched on this machine. Earlier known as Minions\r\n\r\n* **Cluster**- set of nodes grouped together, if one node fails you can use other one. \r\n\r\n* **Master**- Watches over the nodes in cluster\r\n\r\n* **Container runtime**- A container runtime is software that executes containers and manages container images on a node. Today, the most widely known container runtime is Docker, but there are other container runtimes in the ecosystem, such as rkt, containerd, and lxd\r\n\r\n## What components are installed when you install Kubernetes on system?\r\n\r\n**API** (act as frontend for kubernetes; exposes a set of capabilities allowing us to define how we want to define our workloads)\r\n\r\n**etcd** (distributed key-value store)\r\n\r\n**Kubelet** (agent that runs on each node on the cluster; Helps in scheduling & nodes are healthy)\r\n\r\n**Container Runtime** (we will use docker in our case but can be rkt, CRI-O etc.)\r\n\r\n**Scheduler**( distributing containers)\r\n\r\n**Controller** (when nodes or endpoints go down these are used)\r\n\r\n## MASTER vs WORKER Nodes\r\n\r\n**Worker Node**:- This contains **Container Runtime** , **Kubelet** (agent that talks with master & tells about health of worker node to master node; it also carries out the actions from master onto the worker node) components\r\n\r\n**Master Node**:- This contains the **Kube-apiserver** , **etcd** (Key-value), **controller** , **scheduler** components\r\n\r\n## Command Line\r\n\r\n#### Kubectl\r\n\r\n `kubectl run` (this command deploys the application on the cluster)\r\n\r\n `kubectl cluster-info` (info about the cluster)\r\n\r\n `kubectl get nodes` (all nodes part of the cluster)\r\n\r\n `kubectl get pods` (all pods part of the node)\r\n\r\n `kubectl describe pod <pod_name>` (details about the particular pod)\r\n \r\n `kubectl run <pod_name_you_want_to_keep> --image=<image_name>` (Another way to create a pod with the image used)\r\n\r\n `kubectl edit pod <pod_name>` (edit the yml file for that pod)\r\n  \r\n `kubectl create -f pod-definition.yml` (creates a new pod using playbook)\r\n\r\n `kubectl delete deployment <pod name>` (deletes the pod deployed)\r\n  \r\n `kubectl delete pod <pod_name>` (deletes the pod)\r\n  \r\n `kubectl create -f rc-definition.yml` (create RC)\r\n\r\n `kubectl get replicationcontroller` (displays the rc's) \r\n\r\n `kubectl get pods` (if you see anything that has the name rc in it that'll correspond to replication controller)\r\n  \r\n `kubectl create -f replicaset-definition.yml` (create RC)\r\n\r\n `kubectl get replicaset` (displays the rc's) \r\n\r\n `kubectl get pods` (if you see anything that has the name replicaset in it that'll correspond to replication controller)\r\n\r\n `kubectl get deployments` (to get all the deployment objects created)\r\n\r\n `kubectl create -f deployment-definition.yaml` (create deployment pods)\r\n\r\n `kubectl get pods --all-namespaces` (to list pods of all namespaces)\r\n\r\n  **Scaling replicaset(rs) pods**\r\n  \r\n * One, Edit the `replicaset-definition.yml` & change the replicas from 3 to 6 \r\n\r\n * Now, run `kubectl replace -f replicaset-definition.yml`\r\n\r\n * Second, `kubectl scale --replicas=6 -f replicaset-definition.yml`\r\n\r\n * Third, `kubectl scale rs <replica-set-name> --replicas=5`\r\n\r\n `kubectl delete replicaset <replicaset_name>` (This deletes all underlying PODs)\r\n  \r\n `kubectl get all` ( To see all the objects created)\r\n\r\n `kubectl get pods --namespace=<namespace>` (To view all pods within a namespace)\r\n\r\n `kubectl create -f pod-definition.yml --namespace=<namespace_name>` (To create pod with a namespace) \r\n   \r\n `kubectl create -f Compute-quota.yaml` (defining resource quota to limit resources used by a namespace)\r\n\r\n `kubectl create configmap <config-name> --from-literal=<key>=<value>`\r\n \r\n `kubectl create configmap <config-name> --from-file=<path-to-file>\r\n\r\n `kubectl get configmaps`\r\n\r\n `kubectl create secret generic <secret-name> --from-literal=<key>=<value>`\r\n\r\n  Now, the below part shouldn't be in a plain text format\r\n\r\n  ```\r\n  data:\r\n    DB_Host: mysql\r\n    DB_User: root\r\n    DB_Password: password\r\n  ```\r\n\r\n  So, in linux:\r\n\r\n  `echo -n 'mysql' | base64\r\n\r\n  `echo -n 'root' | base64`\r\n\r\n  `echo -n 'password' | base64`\r\n\r\n  **The output for all above will be a hashed format, use that in the yaml file instead**\r\n\r\n  `kubectl get secrets` (shows the attributes but hides the value)\r\n\r\n  `kubectl get secret app-secret -o yaml` (shows the attributes & value)\r\n\r\n  `kubectl describe secrets`\r\n\r\n  **To decode the hashed values which we made above use the following command:-**\r\n\r\n  `echo -n 'hashed value' | base64 --decode`\r\n\r\n###### Kubectl Debugging\r\n\r\n  `kubectl describe pod <pod name>` (describes everything about that pod, what containers are part of it, when's \r\n   created etc.)\r\n  \r\n  `kubectl logs --previous <pod name>` (debugging commands)\r\n\r\n  `Kubectl create -f namespace-dev.yml` (create namespace)\r\n\r\n   or\r\n\r\n  `kubectl create namespace <namespace_name>`\r\n\r\n   Now, if you want to make a particular namespace as default apart from the actual default namespace:-\r\n\r\n   **Example, we want to make dev ns as default now**\r\n\r\n  `kubectl config set-context $(kubectl config current-context) --namespace=dev`\r\n\r\n   Now, if we do `kubectl get pods` we get the pods of the dev namespace. To list the namespace of other \r\n   \r\n   namespaces such as default we do `kubectl get pods --namespace=default`\r\n\r\n  **If the replica-set pod is giving ImagePullError**\r\n\r\n  There are two options:-\r\n  \r\n  * First, you can delete all the replica set pods. The re-spawned pod will run fine\r\n  \r\n  * Second, you can copy the yaml file that is being used to create the replicaset. \r\n\r\n    `kubectl get rs <replica-set-name> -o yaml > <any-name.yaml>`\r\n   \r\n    Now, delete the original replica set yaml file you just copied.\r\n\r\n    `kubectl delete rs <replica-set-name>`\r\n\r\n    Now, you still have the replica-set yaml file but it uses the correct image.\r\n\r\n\r\nKubernetes **doesn't deploy **container directly on worker nodes, the container are encapsulated into kubernetes object called **pods**. \r\n\r\nPod is the smallest object that you can create in kubernetes. \r\n\r\nIf you need to scale your instance when the userbase increase then, rather than adding a new pod to the same pod, we create a new instance aka pod with same application or container. \r\n\r\n**A single pod can have multiple application which are different but if we want to have the same application installed on the pod then, we usually have a separate pod with same instance inside the cluster**. \r\n\r\n**Pods** take care of the namespaces ex. volume, storage, network etc. We just need to tell which container belong to the particular **pod** & any action taken on a pod can be applied only to those containers inside that particular pod only.\r\n\r\n> Cluster-->Pods-->Container (Docker applications)\r\n\r\n\r\n# YAML\r\n\r\n* Kubernetes uses **YAML** to define the resources that are sent to the API server which end up creating the actual application\r\n\r\n\r\n## Creating POD using YAML \r\n\r\npod-definition.yml\r\n\r\n**(All fields below are required:-)**\r\n```\r\napiVersion: v1(string value)\r\n\r\nkind: Pod(string value) \r\n\r\nmetadata: (Dictionary)\r\n\r\n   name: myapp-pod(string value)---> only values kubernetes expects`\r\n\r\n   labels: (dictionary)--> any values can be underneath this`\r\n\r\n       app: myapp(string value)\r\n\r\n       type: front-end(style value)\r\n\r\nspec: \r\n\r\n   containers: (List/Array)-->since,pod can have multiple containers\r\n\r\n     - name: nginx-container\r\n\r\n       image: nginx\r\n```\r\n\r\n> kubectl(uses yaml playbook)--> API (K8s master node)-->application deployed to worker nodes\r\n\r\n\r\nReady(under kubectl get pods)-> running containers in pod & total containers in pod\r\n\r\n\r\n# Kubernetes Controllers (Brain behind Kubernetes)\r\n\r\nOne of the controller is **Replication controller**\r\n\r\n-> It provides HA by creating pods whenever there is a situation where the pod crashes. It not only provides the re-spawning of the pod capability where it has two pods, it can also do the same thing when there is one pod too.\r\n\r\n-> **Replica Set** is the new technology replacing **Replica Controller**\r\n\r\n\r\n## Creating RC(replication Controller) using YAML \r\n\r\nrc-definition.yml\r\n\r\n**(All fields below are required:-)**\r\n```\r\napiVersion: v1(string value)\r\n\r\nkind: ReplicationController(string value) \r\n\r\nmetadata: (Dictionary)\r\n\r\n   name: myapp-rc(string value)---> only values kubernetes expects`\r\n\r\n   labels: (dictionary)--> any values can be underneath this`\r\n\r\n       app: myapp(string value)\r\n\r\n       type: front-end(style value)\r\n\r\nspec:\r\n template:\r\n(the part below is taken from pod-definition.yml exactly. *Check above* )\r\n  metadata: (Dictionary)\r\n\r\n   name: myapp-pod(string value)---> only values kubernetes expects`\r\n\r\n   labels: (dictionary)--> any values can be underneath this`\r\n\r\n       app: myapp(string value)\r\n\r\n       type: front-end(style value)\r\n\r\n  spec: \r\n\r\n   containers: (List/Array)-->since,pod can have multiple containers\r\n\r\n     - name: nginx-container\r\n\r\n       image: nginx\r\n replicas: 3(template & replicas are direct child of rc spec)\r\n\r\n   \r\n```\r\n\r\n`kubectl create -f rc-definition.yml` (create RC)\r\n\r\n`kubectl get replicationcontroller` (displays the rc's) \r\n\r\n`kubectl get pods` (if you see anything that has the name rc in it that'll correspond to replication controller)\r\n\r\n\r\n## Creating replicaset using YAML \r\n\r\nreplicaset-definition.yml\r\n\r\n**(All fields below are required:-)**\r\n```\r\napiVersion: *apps/v1*(string value)\r\n\r\nkind: ReplicaSet(string value) \r\n\r\nmetadata: (Dictionary)\r\n\r\n   name: myapp-replicaset(string value)---> only values kubernetes expects`\r\n\r\n   labels: (dictionary)--> any values can be underneath this`\r\n\r\n       app: myapp(string value)\r\n\r\n       type: front-end(style value)\r\n\r\nspec:\r\n template:\r\n(the part below is taken from pod-definition.yml exactly. *Check above*)\r\n  metadata: (Dictionary)\r\n\r\n   name: myapp-pod(string value)---> only values kubernetes expects`\r\n\r\n   labels: (dictionary)--> any values can be underneath this`\r\n\r\n       app: myapp(string value)\r\n\r\n       type: front-end(style value)\r\n\r\n  spec: \r\n\r\n   containers: (List/Array)-->since, pod can have multiple containers\r\n\r\n     - name: nginx-container\r\n\r\n       image: nginx\r\n replicas: 3(template & replicas are direct child of rc spec)\r\n *selector*: (additional to rc, this helps replicaset to determine what pods fall under replicaset because it can also manage pods that were not created as part of replicaset apart from the ones it is creating above in this yml file)\r\n    matchlabels:\r\n      type: front-set\r\n\r\n   \r\n```\r\n`kubectl create -f replicaset-definition.yml` (create RC)\r\n\r\n`kubectl get replicaset` (displays the rc's) \r\n\r\n`kubectl get pods` (if you see anything that has the name replicaset in it that'll correspond to replication controller)\r\n\r\n\r\n# LABELS & SELECTORS\r\n\r\n* Replicaset deploy new pods if there is a damaged one\r\n\r\n* Replicaset is a process that monitors our existing pods\r\n\r\n### How does replicaset know which pods to monitor?\r\n\r\n* Labels helps replicaset here\r\n\r\n* In **replicaset-definition.yml** under selector, we use the matchLabels to match the labels we use while creating the pods in **pod-definition.yml**\r\n\r\n### Do we need `template` section in `replicaset-definition.yml` eventhough the pods are already defined in `pod-definition.yml`?\r\n\r\n* Yes, we do need it in replicaset because at some point if one of the pods go down, replicaset will help re-spawn the pod. So, the definition of the pod is required in the template section of the replciaset.\r\n\r\n# Scale\r\n\r\n**If now we need to increase the number of replicas to be 6 rather than 3**\r\n\r\nTwo ways:-\r\n\r\n* One, Edit the `replicaset-definition.yml` & change the replicas from 3 to 6 \r\n\r\n* Now, run `kubectl replace -f replicaset-definition.yml`\r\n\r\n* Second, `kubectl scale --replicas=6 -f replicaset-definition.yml`\r\n\r\n\r\n\r\n# Formatting Output with Kubectl\r\n\r\n\r\nThe -o flag allows us to output the details in several different formats.\r\n\r\n**kubectl [command] [TYPE] [NAME] -o <output_format>**\r\n\r\nHere are some of the commonly used formats:\r\n\r\n\r\n\r\n* `-o json` Output a JSON formatted API object.\r\n\r\n* `-o name` Print only the resource name and nothing else.\r\n\r\n* `-o wide` Output in the plain-text format with any additional information.\r\n\r\n* `-o yaml` Output a YAML formatted API object.\r\n\r\nHere are some useful examples:\r\n\r\n* Output with JSON format:\r\n\r\n```\r\nmaster $ kubectl create namespace test-123 --dry-run -o json\r\n{\r\n    \"kind\": \"Namespace\",\r\n    \"apiVersion\": \"v1\",\r\n    \"metadata\": {\r\n        \"name\": \"test-123\",\r\n        \"creationTimestamp\": null\r\n    },\r\n    \"spec\": {},\r\n    \"status\": {}\r\n}\r\nmaster $\r\n```\r\n\r\n* Output with YAML format:\r\n\r\n```\r\nmaster $ kubectl create namespace test-123 --dry-run -o yaml\r\napiVersion: v1\r\nkind: Namespace\r\nmetadata:\r\n  creationTimestamp: null\r\n  name: test-123\r\nspec: {}\r\nstatus: {}\r\n```\r\n\r\n* Output with wide (additional details):\r\n\r\n```\r\nmaster $ kubectl get pods -o wide\r\nNAME      READY   STATUS    RESTARTS   AGE     IP          NODE     NOMINATED NODE   READINESS GATES\r\nbusybox   1/1     Running   0          3m39s   10.36.0.2   node01   <none>           <none>\r\nningx     1/1     Running   0          7m32s   10.44.0.1   node03   <none>           <none>\r\nredis     1/1     Running   0          3m59s   10.36.0.1   node01   <none>           <none>\r\nmaster $\r\n```\r\n\r\n# Namespace\r\n\r\n* Resources within a ns can call each other with their name but to call a service from another ns\r\n\r\n**DNS**\r\n\r\n`<service>.<namespace_to_call_service_from>.(service)svc.(domain)cluster.local`\r\n\r\n#### To view all pods within a namespace\r\n\r\n`kubectl get pods --namespace=<namespace>`\r\n\r\n**kubectl get pods** uses namespace as **default** by default\r\n\r\n#### To create pod with a namespace\r\n\r\n`kubectl create -f pod-definition.yml --namespace=<namespace_name>`\r\n\r\n#### How to create a namespace?\r\n\r\nnamespace-dev.yml\r\n``` \r\napiVersion: v1\r\nkind: Namespace\r\nmetadata:\r\n  name: dev\r\n```\r\n\r\n`Kubectl create -f namespace-dev.yml`\r\n\r\nor\r\n\r\n`kubectl create namespace <namespace_name>`\r\n\r\nNow, if you want to make a particular namespace as default apart from the actual default namespace:-\r\n\r\n**Example, we want to make dev ns as default now**\r\n\r\n`kubectl config set-context $(kubectl config current-context) --namespace=dev`\r\n\r\nNow, if we do `kubectl get pods` we get the pods of the dev namespace. To list the namespace of other namespaces such as default we do `kubectl get pods --namespace=default`\r\n\r\n`kubectl get pods --all-namespaces` (to list pods of all namespaces)\r\n\r\n# Resource Quota\r\n\r\nTo limit resources in ns create a resource quota\r\n\r\nCompute-quota.yaml\r\n```\r\napiVersion: v1\r\nkind: ResourceQuota\r\nmetadata:\r\n  name: compute-quota\r\n  namespace: dev\r\nspec: \r\n  hard:\r\n    pods: \"10\"\r\n    requests.cpu: \"4\"\r\n    requests.memory: 5Gi\r\n    limits.cpu: \"10\"\r\n    limits.memory: 10Gi\r\n```\r\n\r\n`kubectl create -f Compute-quota.yaml`\r\n\r\n\r\n# Configuration\r\n\r\n* **Entrypoint** in ubuntu corresponds to **Command** in definition.yml file\r\n\r\n* **CMD** in ubuntu corresponds to **args** in definition.yml file\r\n\r\n\r\n# Env Variables in Kubernetes\r\n\r\nIn our earlier **pod-definition.yaml**, we add **env** property \r\n\r\n\r\n```\r\napiVersion: v1(string value)\r\n\r\nkind: Pod(string value) \r\n\r\nmetadata: (Dictionary)\r\n\r\n   name: myapp-pod(string value)---> only values kubernetes expects`\r\n\r\n   labels: (dictionary)--> any values can be underneath this`\r\n\r\n       app: myapp(string value)\r\n\r\n       type: front-end(style value)\r\n\r\nspec: \r\n\r\n   containers: (List/Array)-->since,pod can have multiple containers\r\n\r\n     - name: nginx-container\r\n\r\n       image: nginx\r\n\r\n       env:\r\n         - name: APP_COLOR\r\n           value: pink\r\n```\r\nOR\r\n\r\n\r\n`docker run -e APP_COLOR=pink simple-webapp-color`\r\n\r\n\r\n##### Env Value Types\r\n\r\n* **Plain Key Value**\r\n```\r\nenv:\r\n\r\n  - name: APP_COLOR\r\n    value: pink\r\n```\r\n\r\n* **ConfigMap**\r\n```\r\nenv:\r\n  - name: APP_COLOR\r\n    valueFrom:\r\n        configMapKeyRef:\r\n```\r\n\r\n* **Secrets**\r\n```\r\nenv:\r\n  - name: APP_COLOR\r\n    valueFrom:\r\n        secretKeyRef:\r\n```\r\n\r\n##### ConfigMap\r\n\r\n2 phases:-\r\n\r\n* Create ConfigMap\r\n* Inject into pod\r\n\r\n\r\n**Create ConfigMap**\r\n\r\n1. Imperative way\r\n2. Declarative way\r\n\r\nImperative way:- \r\n\r\n`kubectl create configmap <config-name> --from-literal=<key>=<value>`\r\n\r\nEx. `kubectl create configmap app-config --from-literal=APP_COLOR=pink`\r\n\r\n\r\nwhen you have too many configuration items use path to file->\r\n\r\n`kubectl create configmap <config-name> --from-file=<path-to-file>\r\n\r\nEx. `kubectl create configmap app-config --from-file=app_config.properties`\r\n\r\n\r\nDeclarative way:-\r\n\r\n`kubectl create -f config-map.yaml`\r\n\r\nconfig-map.yaml\r\n```\r\napiVersion: v1\r\nkind: ConfigMap\r\nmetadata:\r\n  name: app-config\r\ndata:\r\n  APP_COLOR: blue\r\n  APP_MODE: prod\r\n```\r\n\r\n#### View ConfigMaps\r\n\r\n`kubectl get configmaps`\r\n\r\n`kubectl describe configmaps`\r\n\r\n#### ConfigMap in Pods\r\n\r\npod-definition.yaml\r\n```\r\napiVersion: v1\r\nkind: Pod\r\nmetadata: \r\n  name: simple-webapp-color\r\n  labels:\r\n    name: simple-webapp-color\r\nspec:\r\n  containers:\r\n  - name: simple-webapp-color\r\n    image: simple-webapp-color\r\n    ports:\r\n      - containerPort: 8080\r\n    envFrom:\r\n      - configMapRef:\r\n           name: app-config\r\n      \r\n```\r\n\r\nthe name: app-config **refers** to \r\n\r\nconfig-map.yaml\r\n```\r\napiVersion: v1\r\nkind: ConfigMap\r\nmetadata:\r\n  name: app-config\r\ndata:\r\n  APP_COLOR: blue\r\n  APP_MODE: prod\r\n```\r\n\r\nHere, you referred the config map definition through the pod definition.\r\n\r\n**ENV**\r\n```\r\nenvFrom:\r\n  - configMapRef:\r\n      name: app-config\r\n```\r\n\r\n**Single Env**\r\n```\r\nenv:\r\n  - name: APP_COLOR\r\n    valueFrom:\r\n       configMapKeyRef:\r\n          name: app-config\r\n          key: APP_COLOR\r\n```\r\n\r\n**VOLUME**\r\n```\r\nvolumes:\r\n- name: app-config-colume\r\n  configMap:\r\n    name: app-config\r\n```\r\n\r\n##### Secrets\r\n\r\nTwo Steps:\r\n\r\n* Create Secret\r\n* Inject into pod\r\n\r\n#### Create secret -> 1. Imperative(without generating a secret file) 2. Declarative (using a config file)\r\n\r\n1. Imperative\r\n\r\n\r\n`kubectl create secret generic <secret-name> --from-literal=<key>=<value>`\r\n\r\nEx. `kubectl create secret generic app-secret --from-literal=DB_Host=mysql`\r\n\r\nwhen you have too many configuration items use path to file->\r\n\r\n`kubectl create secret generic app-secret <secret-name> --from-file=<path-to-file>\r\n\r\nEx. `kubectl create secret generic app-secret --from-file=app_config.properties`\r\n\r\n\r\n2. Declarative\r\n\r\n`kubectl create -f secret-daya.yaml`\r\n\r\nsecret-data.yaml\r\n\r\n```\r\napiVersion: v1\r\nkind: Secret\r\nmetadata:\r\n  name: app-secret\r\ndata:\r\n  DB_Host: mysql\r\n  DB_User: root\r\n  DB_Password: password\r\n```\r\n\r\nNow, the below part shouldn't be in a plain text format\r\n\r\n```\r\ndata:\r\n  DB_Host: mysql\r\n  DB_User: root\r\n  DB_Password: password\r\n```\r\n\r\nSo, in linux:\r\n\r\n`echo -n 'mysql' | base64\r\n\r\n`echo -n 'root' | base64`\r\n\r\n`echo -n 'password' | base64`\r\n\r\n**The output for all above will be a hashed format, use that in the yaml file instead**\r\n\r\n`kubectl get secrets` (shows the attributes but hides the value)\r\n\r\n`kubectl get secret app-secret -o yaml` (shows the attributes & value)\r\n\r\n`kubectl describe secrets`\r\n\r\n**To decode the hashed values which we made above use the following command:-**\r\n\r\n`echo -n 'hashed value' | base64 --decode`\r\n\r\n#### Secret in Pods\r\n\r\npod-definition.yaml\r\n```\r\napiVersion: v1\r\nkind: Pod\r\nmetadata: \r\n  name: simple-webapp-color\r\n  labels:\r\n    name: simple-webapp-color\r\nspec:\r\n  containers:\r\n  - name: simple-webapp-color\r\n    image: simple-webapp-color\r\n    ports:\r\n      - containerPort: 8080\r\n    envFrom:\r\n      - secretRef:\r\n           name: app-secret\r\n      \r\n```\r\n\r\nthe name: app-secret **refers** to \r\n\r\nsecret-data.yaml\r\n```\r\napiVersion: v1\r\nkind: Secret\r\nmetadata:\r\n  name: app-secret\r\ndata:\r\n  DB_Host: hashed value(mysql)\r\n  DB_User: hashed value(root)\r\n  DB_Password: hashed value(password)\r\n```\r\n\r\nHere, you referred the secret-data definition through the pod definition.\r\n\r\n**ENV**\r\n```\r\nenvFrom:\r\n  - secretRef:\r\n      name: app-config\r\n```\r\n\r\n**Single Env**\r\n```\r\nenv:\r\n  - name: DB_Password\r\n    valueFrom:\r\n       secretKeyRef:\r\n          name: app-secret\r\n          key: DB_Password\r\n```\r\n\r\n**VOLUME**\r\n```\r\nvolumes:\r\n- name: app-secret-volume\r\n  secret:\r\n    name: app-secret\r\n```\r\n\r\nIf I use volumes as one of my method then to retrieve the actual value I have to visit:-\r\n\r\n`ls /opt/app-secret-volumes`\r\n\r\n`cat /opt/app-secret-volumes/DB_Host`\r\n\r\n`cat /opt/app-secret-volumes/DB_User`\r\n\r\n`cat /opt/app-secret-volumes/DB_Password`\r\n\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}